\section{Related Work}
\label{sec.related_work}

This section discusses tools and techniques that have similar goals
with Lind to realize privileged code protection through strong
isolation between userspace and kernelspace.
	
\subsection{Virtualization}

Programming languages that provide safety through virtualization such
as Java, JavaScript, Lua~\cite{Lua}, and
Silverlight~\cite{Silverlight} are commonly used in application-level
sandboxing. These safe languages provide virtualized environments to
check the safety of the running code by a monitor process. These
sandboxes combine untrusted application code with an interpreter and
standard libraries that consolidate routines to perform I/O, network
communication, and other sensitive functions. For example, the Java
Virtual Machine (JVM) \cite{JVM} functions as an application-level
sandbox to separate untrusted code from the OS in addition to
performing safety checks for avoiding unauthorized branching in
memory.

There are sandboxing solutions based on type-safety of programming
languages, i.e. validating through a type-checker \cite{JS-Sandboxing}
or enforcing security policies on an untrusted system through a
reference monitor \cite{JS-Sandboxing1}. Compared to these approaches,
Lind provides more portability than just executing the code in a
safe-sandbox browser. \yanyan{why browser? it says programming
languages in the previous sentence.}Lind enforces strict policies and
rules to validate all segments of a code before executing it through a
dual-layer protection.

Many sandboxes can implement the bulk of standard libraries in a
memory-safe language like Java or C\#, flaws in memory-safe code can
still pose a threat. In fact, many security critical bugs can be found
in the standard libraries \cite{JavaBugs}. Researchers have also
discovered many severe bugs in Java \cite{Java-Lessons}.
Unfortunately, any bug or failure in a programming language virtual
machine is usually fatal. Lind with a very small TCB (approximately
8,000 LOC) enhances security compared to the above virtual machines,
because of the POSIX implementation with Repy to build the sandbox.

OS virtualization techniques can be divided into two large categories:
Type-I or Type-II virtualization. Examples of Type-I virtualization
(bare-metal hardware virtualization) are VMware ESX Server, Xen,
LXC~\cite{LXC}, BSDâ€™s jail, Solaris zones, and Hyper-V. Type-II
virtualization (hosted hypervisor virtualization) examples are VMware
Workstation, VMware Server, VirtualPC and the open-source counterpart
VirtualBox.


Security by isolation \cite{Qubes}, \cite{Overshadow},
\cite{SecureVM}, \cite{HypSec} is a feature of OS virtualization to
provide safe executing environments through containment for multiple
user-level virtual environments that share the same hardware. This
approach relies on the VMM to confine untrusted applications within
guest OSs. However, there are limitations with virtualization due to
the large attack vectors against the hypervisors including
vulnerabilities of software and configuration risk. For example, the
small code footprint of a hypervisor can become a potential
vulnerability and lead to serious problems. Maintaining two OSs in
virtulized environments is among the other issues that add complexity
\cite{Virt-Issues}. Attackers are able to exploit vulnerabilities to
escape these systems and access arbitrary code in the underlying host
systems. Lind deals with these concerns by using a much smaller and
safer TCB.

Library OSes are a useful approach for applications to efficiently
obtain the benefits of virtual machines,
including security isolation, host platform compatibility, and
migration. Drawbridge \cite{Drawbridge-11} is a new program
that uses lightweight processes and a library OS to present a Windows
persona to a wide variety of Windows applications.
This is accomplished by moving a large portion of the OS into the
process, and presenting a simplified system
virtual machine-like interface to each process. This approach brings
many of the benefits of VM based temporal,
spatial and fault isolation properties to a per-process level. Bascule
\cite{Bascule}, an architecture for library OS extensions
based on Drawbridge, allows application behavior to be customized by
extensions loaded at runtime.
Graphene \cite{Graphene-14} is a recent library OS system that
seamlessly and efficiently executes both single and
multi-process applications, generally with low memory and performance
overheads.
It broadens the library OS paradigm to support secure, multi-process
APIs, such as copy-on-write fork, signals,
and System V IPC. Haven \cite{Haven} uses a library OS to implement
shielded execution of unmodified server applications
in an untrusted cloud host. Haven leverages the hardware protection of
Intel SGX to defend against
privileged code and physical attacks, such as memory probes, but also
addresses the dual challenges of
executing unmodified legacy binaries and protecting them from a
malicious host.
The library OS technique is similar to Lind but differs in the fact
that existing library OS systems rely heavily on
the underlying kernels to perform system functions, while Lind only
relies on a very limited set of system functions,
and reconstructs most OS functions with our own safe Repy code. 

\subsection{System Call Interposition}

System call interposition offers a number of properties that make it
attractive for building sandboxes, though it can be error prone
\cite{SCI-04}. Approaches for delegation and filtering have been
extensively studied,
along with their respective tradeoffs between security and
performance.
Janus Version 2 (J2) \cite{Janus0:96, Janus:99} uses filtering and
sandboxing, while Ostia \cite{SCI-04} uses a delegation.
Ostia also provides a hybrid interposition architecture, which allows
for kernel level enforcement and user policies.

The kernel module enforces policy, denies direct access to restricted
resources,
and delegates certain calls to the emulation library, which sends
transformed system calls to the agents.
The agent reads the policy file and handles the delegation of calls.
However, system call interposition has many problems.

OS semantics are very difficult to replicate correctly. Indirect paths
to resources are often overlooked,
and there are side effects to denying system calls
\cite{Problems-SCI}.
Nevertheless, this technique is very useful and has inspired many new
techniques, such as library OSes.
The concepts behind System Call Interposition have evolved into other
modern techniques
and has benefitted many security systems, including Lind. 

\subsection{Software Fault Isolation}
Software Fault Isolation (SFI) is an alternative to hardware memory
protection for running two applications in one address space by
instruction rewriting. SFI provides sandboxing in which native
instructions can only be executed if they do not violate the sandbox's
constraints \cite{SFI:93}. This goal is achieved through machine-level
code analysis to enforce security policies. In this approach, memory
writes are protected and code jumps cannot access predefined memory of
other programs or executing other programs codes in memory.

Nooks \cite{Nooks:03} is another SFI-based solution that provides
protected environment for running device drivers by isolating kernel
modules and device derives mainly for reliability and
fault-resistance. Nooks runtime environment is located within the
kernel and it includes majority of drivers that needs to be protected
from each other, i.e. network nook and video nook are two protection
domains without the possibility for memory writes outside their
protection domain. The Nook layer function as a reference monitor
between device devices and physical hardware by forwarding interrupts
Nooks also wrap calls from the operating system kernel into device
drivers and from device drivers into the kernel, allowing the
operating system to track resource usage and verify data that is
passed into and out of the kernel. Object tracking to allow OS for
resource consumption is another feature of wrappers in Nooks.


The preliminary design of SFI approach was build on RISC
architectures. In PittSFIeld \cite{PittSFIeld}, authors optimized and
extended the original SFI to support CISC architectures. For this
purpose, the source instructions are padded with no-ops to fit, i.e.
in the 16-byte x86 byte chunk alignment, where a call instruction is
appended. A sequence of instructions form a instruction streams that
ensures execution order of the sequence. The final code before
execution will be checked by a verifier component to ensure safety.
The authors used machine-checked proof for increased assurance that
verifier only approves safe operations.

SFI has been also used in MisFIT \cite{MISFit} to ensure kernel
modules integrity for x86. The authors have emphasized on the
extendability of object-oriented programming languages to eliminate
the need for remote calls to achieve high throughput sandboxes. SFI
containers embody the extensions to demonstrate the integrity
validation check in conjunction with the host environment resources.

To enforce the safety constraints, programs demand a specific compiler
in advance to validation and loading the programs. For example, in
\cite{Castro-BGI} authors introduced a SFI system called Byte
Granularity Isolation (BGI) as a runtime tool to isolate drivers in
separate protection SFI domains, while sharing the same address space
between different domains. BGI mainly ensures write-integrity,
control-flow integrity and type safety for kernel objects. For this
purpose, a BGI compiler is required to transform the unmodified driver
source code to instrumented driver. The instrumented driver will be
linked to the BGI interposition libraries that enforce the protection
constraints to produce the BGI drivers. The protection constraints
that are enforced by the interposition library are implemented in
access control lists (ACL). The ACLs contain policies for each byte of
virtual memory and domain permissions. A major issue of BGI is that it
does not solve the vulnerabilities in kernel-level and it only deals
with specific attacks that aim to pass by a faulty domain.


Recently, Google provided Native Client (NaCl) \cite{NaCl-09} for
Chrome browser to allow native executable code to be run directly in a
browser using the PittSFIeld semantics. NaCl prevents suspicious codes
for memory corruption or direct access to the underlying system
resources. For this purpose NaCl loads untrusted modules from the
trusted modules into two different address spaces, where in most SFI
approaches both untrusted and trusted codes are loaded into a common
address space.

Mao et al. \cite{LXFI} study the shortcomings of XFI \cite{XFI} and
BGI \cite{Castro-BGI} kernel module isolation mechanisms that separate
kernel modules from the core kernel. Integrity of API calls was one of
the challenging issues in existing solutions. For example in XFI there
were no argument validation. LXFI solution was proposed as an
extension of existing SFI solutions with language annotation. LXFI
added argument integrity in XFI and call back integrity in BGI in
addition to enabling programmers for specifying principals for access
permissions within a module.

In another effort \cite{PSFI}, Kroll et al. discuss the issues of
machine-level SFI that causes portability limitations across different
hardware architectures. The authors propose portable SFI through a
higher level of abstraction at the compiler layer. To this end,
programs are rewritten by an intermediate-level language compiler to
comply with policies.



