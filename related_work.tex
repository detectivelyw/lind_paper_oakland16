\section{Related Work}
\label{sec.related_work}
\cappos{extremely weak}

This section discusses tools and techniques that have similar goals with Lind to realize privileged code protection through strong isolation between userspace and kernelspace.

	
\subsection{Virtualization}

Programming languages that provide safety through virtualization such as Java, JavaScript, Lua\footnote{http://www.lua.org/}, and Silverlight\footnote{http://www.microsoft.com/silverlight/} are commonly used in application-level sandboxing. The key idea behind these safe languages to provide virtualized environments to check safety of the running code operations by a monitor process. These sandboxes combine untrusted application code with an interpreter and standard libraries that consolidate routines to perform I/O, network communication, and other system sensitive functions. For example, the Java Virtual Machine (JVM) \cite{JVM} that functions as an application-level sandbox to separate untrusted code from the OS in addition to performing safety checks for avoiding unauthorized branching in memory. 

There have been sandboxing solutions introduced based on type-safety of programming languages to build sandboxes, i.e. validating through a type-checker \cite{JS-Sandboxing} or enforcing security policies on an untrusted system through a reference monitor \cite{JS-Sandboxing1}. Compared to these approaches, Lind provides more portability than just executing the code in a safe-sandbox browser. Lind enforces strict policies and rules to validate all segments of a code before executing it through a dual-layer protection.

Many sandboxes can implement the bulk of standard libraries in a memory-safe language like Java or C\#, flaws in memory-safe code can still pose a threat. In fact, many security critical bugs can be found in the standard libraries \cite{JavaBugs}. Researchers have also discovered many severe bugs in Java \cite{Java-Lessons}. Unfortunately, any bug or failure in a programming language virtual machine is usually fatal. Lind with a very small TCB (approximately 8000 LOC) enhances security compared to the above virtual machines, because of the POSIX implementation with Repy to build the sandbox.

OS virtualization techniques can be divided into two large categories:  Type-I or Type-II virtualization. Examples of Type-I virtualization (bare-metal hardware virtualization) are VMware ESX Server, Xen, LXC\footnote{https://linuxcontainers.org}, BSDâ€™s jail, Solaris zones, and Hyper-V. Type-II virtualization (hosted hypervisor virtualization) examples are VMware Workstation, VMware Server, VirtualPC and the open-source counterpart VirtualBox. 


Security by isolation \cite{Qubes}, \cite{Overshadow}, \cite{SecureVM}, \cite{HypSec} is a feature of OS virtualization to provide safe executing environments through containment for multiple user-level virtual environments that share the same hardware. This approach relies on the VMM to confine untrusted applications within guest OSs. However, there are limitations with virtualization due to the large attack vectors against the hypervisors including vulnerabilities of software and configuration risk. For example, the small code footprint of a hypervisor can become a potential vulnerability and lead to serious problems. Maintaining two OSs in virtulized environments is among the other issues that add complexity \cite{Virt-Issues}. Attackers are able to exploit vulnerabilities to escape these systems and access arbitrary code in the underlying host systems. Lind deals with these concerns by using a much smaller and safer TCB.

Library OSes are a useful approach for applications to efficiently obtain the benefits of virtual machines, 
including security isolation, host platform compatibility, and migration. Drawbridge \cite{Drawbridge-11} is a new program 
that uses lightweight processes and a library OS to present a Windows persona to a wide variety of Windows applications. 
This is accomplished by moving a large portion of the OS into the process, and presenting a simplified system 
virtual machine-like interface to each process. This approach brings many of the benefits of VM based temporal, 
spatial and fault isolation properties to a per-process level. Bascule \cite{Bascule}, an architecture for library OS extensions 
based on Drawbridge, allows application behavior to be customized by extensions loaded at runtime. 
Graphene \cite{Graphene-14} is a recent library OS system that seamlessly and efficiently executes both single and 
multi-process applications, generally with low memory and performance overheads. 
It broadens the library OS paradigm to support secure, multi-process APIs, such as copy-on-write fork, signals, 
and System V IPC. Haven \cite{Haven} uses a library OS to implement shielded execution of unmodified server applications 
in an untrusted cloud host. Haven leverages the hardware protection of Intel SGX to defend against 
privileged code and physical attacks, such as memory probes, but also addresses the dual challenges of 
executing unmodified legacy binaries and protecting them from a malicious host. 
The library OS technique is similar to Lind but differs in the fact that existing library OS systems rely heavily on 
the underlying kernels to perform system functions, while Lind only relies on a very limited set of system functions, 
and reconstructs most OS functions with our own safe Repy code. 

\subsection{System Call Interposition}

System call interposition offers a number of properties that make it attractive for building sandboxes, though it can be error prone \cite{SCI-04}. Approaches for delegation and filtering have been extensively studied, 
along with their respective tradeoffs between security and performance. 
Janus Version 2 (J2) \cite{Janus0:96, Janus:99} uses filtering and sandboxing, while Ostia \cite{SCI-04} uses a delegation. 

Ostia also provides a hybrid interposition architecture, which allows for kernel level enforcement and user policies. 

The kernel module enforces policy, denies direct access to restricted resources, 
and delegates certain calls to the emulation library, which sends transformed system calls to the agents. 
The agent reads the policy file and handles the delegation of calls. However, system call interposition has many problems.

OS semantics are very difficult to replicate correctly. Indirect paths to resources are often overlooked, 
and there are side effects to denying system calls \cite{Problems-SCI}. 
Nevertheless, this technique is very useful and has inspired many new techniques, such as library OSes. 
The concepts behind System Call Interposition have evolved into other modern techniques 
and has benefitted many security systems, including Lind. 

\subsection{Software Fault Isolation}
Software Fault Isolation (SFI) is an alternative to hardware memory protection for running two applications in one address space. SFI provides sandboxing in which native instructions can only be executed if they do not violate the sandbox's constraints \cite{SFI:93}. In this approach, memory writes are protected and code jumps  cannot access predefined memory of other programs or executing other programs codes in memory. 

To enforce the safety constraints, programs demand a specific compiler in advance to validation and loading the programs. For example, in \cite{Castro-BGI} authors introduced a SFI system called Byte Granularity Isolation (BGI) as a runtime tool to isolate drivers in separate protection SFI domains, while sharing the same address space between different domains. BGI mainly ensures write-integrity, control-flow integrity and type safety for kernel objects. For this purpose, a BGI compiler is required to transform the unmodified driver source code to instrumented driver. The instrumented driver will be linked to the BGI interposition libraries that enforce the protection constraints to produce the BGI drivers. The protection constraints that are enforced by the interposition library are implemented in access control lists (ACL). The ACLs contain policies for each byte of virtual memory and domain permissions. A major issue of BGI is that it does not solve the vulnerabilities in kernel-level and it only deals with specific attacks that aim to pass by a faulty domain.


Nooks \cite{Nooks:03} is another SFI-based solution that isolates kernel modules and device derives.


 
They use two techniques: sandboxing and micro-reboots. Nooks uses both as SFI-based and user-level sandboxes. 

Micros-reboots conceptually refresh small parts of the system. 
Google's Native Client \cite{NaCl-09} adopts SFI to execute untrusted x86 binary code safely. 

We leveraged this technique and used NaCl in our system Lind. The difference is that SFI doesn't handle the manner 
in which systems interact with the underlying OS. In NaCl, to perform system calls, it relies on a trusted service runtime for thread creation, memory management, and other system services. 

In Lind, we redirect system call requests to our safe POSIX interface, 
which allows Lind to control its own interaction with the underlying OS kernel.