\section{Motivation and Background}
\label{sec.motivation-and-background}

In this section, we present some background information 
relevant to the development of our design metric and the Lind prototype. 
This includes a broader discussion of the problem of kernel exploitation, 
and the limitations of previous protection strategies. 
%caused by an inability to identify which portions of the kernel are risky. 
We also share a few assumptions about the specific threats 
that the safety metric and the Lind prototype system are designed to
address.

\subsection{Kernel and Vulnerabilities}

Running user applications relies on the operating system kernel 
accessing critical resources, such as memory, I/O, or CPU. 
The kernel provides an interface to serve these requests 
and provides essential functionality for all applications running in the
system. 
Thus all code, whether sandboxed or untrusted, will make calls 
that are eventually processed by the kernel. 

Unfortunately, operating system kernels are not safe and secure from
attackers and the situation is worsening over time. 
Over the past few years, the exploitation of OS kernels has been wide
spread, 
despite substantial efforts by researchers and practitioners. 
In 2014, 215 vulnerabilities in all types of kernels were reported~\cite{NVD}, 
and 125 of those vulnerabilities were in the Linux kernel. 
The kernel's
attack surface keeps increasing due to the constant addition of new
features~\cite{Metrics-13}. 
Indeed, the size of the Linux kernel, increased from 6.6 MLOC in v2.6.11 
(March 2005) to 16.9 MLOC in v3.10 (June 2013)~\cite{Linux-13}. 


\cappos{Likely cut this.  I think it is excessive.}
Such a huge kernel codebase has lead to excessive exploitation. 
As a result, the Linux kernel has been plagued by a number of common
software flaws. 
These flaws have raised serious security concerns and caused severe damage
to systems. 
Stack and heap buffer overflow vulnerabilities have been leveraged to 
cause denial of service (system crash)~\cite{CVE-2013-2892}, 
the execution of arbitrary code~\cite{CVE-2009-3234}, 
or to allow local users to gain privileges via a crafted 
application~\cite{CVE-2013-1828}. 
Memory disclosure vulnerabilities have been exploited to allow local users
to read 
the contents of some kernel memory locations~\cite{CVE-2009-3002}, or to
obtain potentially 
sensitive information from kernel stack memory~\cite{CVE-2010-4073}. 
Attackers have also used use-after-free vulnerability to gain kernel
privileges~\cite{CVE-2013-4343}.

%The number of kernel vulnerabilities and their potential for exploitation, 
%plus the fact that user applications rely on the kernel to execute
%programs, 
%present a compelling motive for designing securer systems that can run
%applications with a better degree of safety. \yanyan{this paragraph does 
%not say anything new.}

\subsection{Threat Assumptions}

The primary goal of a secure system is to restrict a program to some subset
of privileges, 
usually by exposing a set of functions that mediate access to the
underlying operating system privileges. 
Threats occur when applications obtain access to privileges that were not
intentionally granted by the system, 
thus losing the intended protection~\cite{Repy-10}. In building a system
that leverages our security metric, 
we make the following assumptions about the threat we seek to address:

\begin{enumerate}
\item We assume that the operating system kernel contains one or more bugs 
that are known to the attacker.

\item We assume the attacker has the ability to execute code inside
of a virtualized system, such as an operating system VM or library OS.
The attacker may either have that access by writing a malicious application
that the user executes or by exploiting a flaw that exists in a user's
application.


\item We assume that unintentional bugs will exist in any complex code.  This
includes any security systems placed between the kernel and the user
applications.

\item We assume it is possible to provide some form of computational 
containment.  This means that an isolated program cannot simply
make arbitrary system calls and access the kernel directly.  This could
be provided through software-fault isolation~\cite{SFI:93}, programming 
language techniques\cappos{cites}, or by running isolated code in a
distinct region of virtual memory\cappos{cites}.

\item We assume it is possible to build functionality that possesses few
vulnerabilities so long as it consists of little code and is conceptually 
simple.
\cappos{How do I explain
the sandbox TCB???  How is this different from a hypervisor?}

\end{enumerate}

