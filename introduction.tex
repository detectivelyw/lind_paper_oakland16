\section{Introduction}
\label{sec.introduction}

To run multiple applications on a computer, it is critical to securely
manage access to the underlying hardware. In modern computer systems,
either a hypervisor, a virtual machine monitor (VMM), or an 
operating system (OS) kernel performs this important function. Unfortunately, code within an operating system kernel
may contain flaws and vulnerabilities. If the kernel is attacked by malicious parties, these flaws can provide the attacker unrestricted access to the system. One critical flaw, discovered in the Linux kernel in the \texttt{futex} subsystem call can allow an attacker to gain ring 0 control via the \texttt{futex} syscall, and potentially execute arbitrary code
with kernel mode privileges~\cite{CVE-2014-3153}. \cappos{Possibly omit
this sentence.}

There is a diverse set of defensive technologies to protect kernels from 
attacks, including OS virtualization, system call filtering, and library OSes.
Common security wisdom is that by running software in a virtual machine, 
one can prevent the attacker from exploiting flaws in the underlying kernel.  However, the security of virtualization itself is a 
challenging issue \cite{Tal}. As we will show later, virtualization cannot prevent about one third of vulnerabilities on the Linux kernel. As such, even with these technologies in place, applications running in a virtual machine still pose a substantial risk.

In this paper, we first develop a metric that helps identify where
within the kernel these vulnerabilities are likely to be located. We
examined 40 kernel patches that fix severe Linux kernel security bugs
and analyzed the lines of the kernel where those bugs occurred.  Our
analysis shows that kernel paths used by popular applications contain fewer
security bugs, and therefore, can be exposed with less risk. 

While limiting access to kernel code is important, it is
insufficient to build a secure virtualization system.  First, if a complex
program is prevented from accessing part of the kernel, its functionality 
must exist somewhere else for this program to work.  Second, it is 
typical for virtualization systems to add new privileged code.
As a result, a vulnerability in the privileged codebase is as much of a security 
risk as an flaw in the kernel.  %However, this privileged code needs to be
%complex because the system must implement complex 
% must exist somewhere or else applications will not run. 
For example, 
a vulnerability in VMWare's codebase caused by buffer overflows in the VIX
API could allow local users to escape out of the guest VM and 
gain privilege escalation to execute arbitrary code in the host
OS, even shellcode to access the kernel of the host OS~\cite{CVE-2008-2100}.  
%\cappos{Revise this paragraph further}

%To address this issue, 
We propose a new design paradigm for virtualization 
systems called ``safely-reimplement'' that restricts access to only the
kernel paths that are mostly used by common applications.  To restrict the privileged
code, we first build a minimal, sandboxed environment that also only uses 
common kernel paths.
We then implement a POSIX interface inside of this safe sandbox, hence the
name safely-reimplement. The safe-reimplementation of POSIX causes the
complex code to be trapped within the sandbox. \yanyan{the sandbox only has
safe code. how can unsafe code to be trapped "within" the sandbox?} Therefore, even if the code
is vulnerable to an attack, it is unable to trigger
kernel paths that are less commonly used or tested.

We use this design paradigm to develop a virtualization system
Lind.  Lind uses Google Native client for software fault isolation (memory
safety of the application) and the Repy sandbox~\cite{Repy-10} to contain the POSIX
implementation and to provide access to the kernel.  This implementation
helped us to understand which kernel paths are hardest to
safely-reimplement and provided key insights about what kernel paths system
designers should give the highest degree of scrutiny. \yanyan{shouldn't it
be the other way round? first fully understand which paths are hard, and
then use this insight to design Lind.}

To evaluate the effectiveness of Lind, we first captured the 
kernel traces from user programs run in Lind and four other virtualization
systems.
%and compare their kernel traces. 
We then examined historical
kernel bug reports to verify which trace was more likely to trigger bugs.
Results showed that applications run in Lind were the least likely to
trigger kernel bugs: only one triggered out of the 35 kernel vulnerabilities 
(2.9\%). In contrast, the virtualization systems built
without our metric triggered more vulnerabilities (23-40\%). This
suggests that our metric can help effectively design and build more secure
virtualization systems.

The main contributions of this paper are as follows: %\cappos{revise}
\begin{itemize}
\item We propose a novel metric for quantitatively measuring and evaluating the
security of privileged code, such as in an OS kernel. Our metric examinesd
the safety of the kernel trace, at the lines-of-code level, generated by
running user applications. This metric is helpful for the design of secure systems.
%\yanyan{what is "generated by producing design recommendations"?}
\item Using our metric, we have substantiated our key hypothesis that commonly
used kernel paths contain fewer bugs. 
\item We create a novel secure ``safely-reimplement'' design by examining and
leveraging our metric and key hypothesis. 
%that commonly used kernel paths contain fewer bugs. 
Our design reimplements risky system calls inside a
sandbox that only uses safe kernel paths. 
\item With this new design, we implemente a sandbox security system, Lind, that
provides a secure environment for applications and strong protection for
the kernel.
\item Results show that the implementation of Lind only triggers one (2.9\%) of
the kernel vulnerabilities we examined, while systems built without using
our metric trigger about an order of magnitude more vulnerabilities. This
suggests that our metric can help design and build virtualization systems
with greater security. 
\end{itemize}
\cappos{Quantitative analysis for sandboxes}


The remainder of this paper is organized as follows. 
We discuss the motivation that drove our work and key background information 
in \S{\ref{sec.motivation-and-background}}. 
In \S{\ref{sec.metric}}, we propose our kernel coverage safety metric. 
%to solve the existing security problems.  
Using this metric, we describe the 
``safely-reimplement'' design pattern in \S{\ref{sec.design}}. In 
\S{\ref{sec.implementation}}, we describe the sandbox security 
system Lind, which is implemented using our design. We use quantitative 
measures to compare the security and efficiency of Lind with other 
virtualization systems in \S{\ref{sec.evaluation}}. 
Limitations and future work are discussed in \S{\ref{sec.limitation}}.  
We then discuss related work in \S{\ref{sec.related_work}} and conclude
in \S{\ref{sec.conclusion}}.

